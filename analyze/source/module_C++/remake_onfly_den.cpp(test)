#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <regex>
#include <cmath>
#include <algorithm>
#include <iomanip>

using namespace std;

// 4D数组: [nx][ny][nz][col]
using Matrix4D = vector<vector<vector<vector<double>>>>;
using Matrix3D = vector<vector<vector<double>>>;

struct LoadDataResult {
    vector<vector<Matrix4D>> ret;
    vector<vector<double>> xyzRange;
    vector<int> nbin;
    vector<double> lowPos;
    vector<double> upPos;
    vector<double> Lbox;
    int totNbin;
    int totFrames;
    int nRegion;
};

vector<double> extractNumbers(const string& str) {
    vector<double> numbers;
    regex number_regex(R"([+-]?\d*\.?\d+(?:[eE][+-]?\d+)?)");
    sregex_iterator iter(str.begin(), str.end(), number_regex);
    sregex_iterator end;
    for (; iter != end; ++iter) {
        numbers.push_back(stod(iter->str()));
    }
    return numbers;
}

vector<string> readTextData(const string& filename) {
    vector<string> textData;
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << filename << endl;
        exit(1);
    }
    string line;
    while (getline(file, line)) {
        if (!line.empty() && (line[0] == '%' || line[0] == '#')) {
            textData.push_back(line);
        }
        else {
            break;  // Stop reading on first non-comment line,it's mean you shoudn't modified the data file format
        }
    }
    file.close();
    return textData;
}

vector<vector<double>> readDataFile(const string& filename) {
    vector<vector<double>> data;
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << filename << endl;
        exit(1);
    }
    string line;
    while (getline(file, line)) {
        if (line.empty() || line[0] == '%' || line[0] == '#') continue;
        
        vector<double> row;
        istringstream iss(line);
        double value;
        while (iss >> value) {
            row.push_back(value);
        }
        if (!row.empty()) {
            data.push_back(row);
        }
    }
    file.close();
    return data;
}

vector<Matrix4D> reshapeColumnMajor(
    const vector<vector<double>>& tmpData,
    int nRegion,
    const vector<int>& nbin,
    int col)
{
    vector<Matrix4D> ret;
    ret.reserve(nRegion);

    size_t tmpIndex = 0;
    size_t totalRows = tmpData.size();

    for (int ii = 0; ii < nRegion; ++ii)
    {
        int n1 = nbin[3 * ii];       // 对应 nbinX
        int n2 = nbin[3 * ii + 1];   // 对应 nbinY
        int n3 = nbin[3 * ii + 2];   // 对应 nbinZ
        size_t eachNbin = static_cast<size_t>(n1) * n2 * n3;

        if (tmpIndex + eachNbin > totalRows)
            throw runtime_error("tmpData size not sufficient for nbin region");

        // 分配 4D 容器
        Matrix4D regionData(
            n1, vector<vector<vector<double>>>(
            n2, vector<vector<double>>(
            n3, vector<double>(col, 0.0))));

        // MATLAB 是列主序: x 最快，y 次，z 次，col 最慢
        size_t idx = 0;
        for (int c = 0; c < col; ++c)
            for (int z = 0; z < n3; ++z)
                for (int y = 0; y < n2; ++y)
                    for (int x = 0; x < n1; ++x)
                    {
                        regionData[x][y][z][c] = tmpData[tmpIndex + idx][c];
                        ++idx;
                    }

        tmpIndex += eachNbin;
        ret.push_back(std::move(regionData));
    }

    // 若只有一个 region，则直接返回它（模拟 MATLAB 的 ret{1}）
    if (nRegion == 1)
        return { ret[0] };
    else
        return ret;
}




LoadDataResult loadOnflyData3D(const string& fnm) {
    LoadDataResult result;
    
    auto textData = readTextData(fnm);
    auto allData = readDataFile(fnm);
    
    // 解析头部 (基于MATLAB的textData索引，从0开始)
    if (textData.size() >= 2) {  // textData{2} -> index 1
        result.Lbox = extractNumbers(textData[1]);
    }
    if (textData.size() >= 3) {  // {3} -> index 2
        result.lowPos = extractNumbers(textData[2]);
    }
    if (textData.size() >= 4) {  // {4} -> index 3
        result.upPos = extractNumbers(textData[3]);
    }
    if (textData.size() >= 6) {  // {6} -> index 5
        auto nbin_nums = extractNumbers(textData[5]);
        result.nbin.resize(nbin_nums.size());
        for (size_t i = 0; i < nbin_nums.size(); ++i) {
            result.nbin[i] = static_cast<int>(nbin_nums[i]);
        }
    }
    
    if (textData.size() >= 8) {  // {8} -> index 7
        auto totNbin_nums = extractNumbers(textData[7]);
        if (!totNbin_nums.empty()) result.totNbin = static_cast<int>(totNbin_nums[0]);
    }
    if (textData.size() >= 9) {  // {9} -> index 8
        auto totFrames_nums = extractNumbers(textData[8]);
        if (!totFrames_nums.empty()) result.totFrames = static_cast<int>(totFrames_nums[0]);
    }
    
    result.nRegion = result.nbin.empty() ? 0 : result.nbin.size() / 3;
    
    // 生成xyzRange (linspace)
    for (size_t ii = 0; ii < result.nbin.size(); ++ii) {
        vector<double> range;
        double start;
        if (ii < result.lowPos.size()) {
            start = result.lowPos[ii];
        } else {
            std::cerr << "Error: lowPos size mismatch!" << std::endl;
            exit(1);
        }

        double end;
        if (ii < result.upPos.size()) {
            end = result.upPos[ii];
        } else {
            std::cerr << "Error: upPos size mismatch!" << std::endl;
            exit(1);
        }

        int points = result.nbin[ii];
        if (points > 1) {
            double step = (end - start) / (points - 1);
            for (int j = 0; j < points; ++j) {
                range.push_back(start + j * step);
            }
        } else {
            range.push_back(end);
        }
        result.xyzRange.push_back(range);
    }
    
    // 处理数据
    // if (result.nRegion != 1) {
    //     cerr << "Warning: Multiple regions not fully implemented. Assuming nRegion=1." << endl;
    // }
    int nx = (result.nRegion >= 1) ? result.nbin[0] : 1;
    int ny = (result.nRegion >= 1) ? result.nbin[1] : 1;
    int nz = (result.nRegion >= 1) ? result.nbin[2] : 1;
    int col = allData.empty() ? 0 : static_cast<int>(allData[0].size());
    
    result.ret.resize(result.totFrames);
    for (int ii = 0; ii < result.totFrames; ++ii) {
        int start_row = ii * result.totNbin;
        int end_row = min((ii + 1) * result.totNbin, static_cast<int>(allData.size()));
        
        vector<vector<double>> frameData;
        for (int j = start_row; j < end_row; ++j) {
            if (j < static_cast<int>(allData.size()) && static_cast<int>(allData[j].size()) == col) {
                frameData.push_back(allData[j]);
            }
        }
        
        result.ret[ii] = reshapeColumnMajor(frameData, result.nRegion, result.nbin, col);
    }
    
    return result;
}

int main() {
    double V = 2.0;
    double scanrate = 0.0;
    
    string filename = "./deal_data/onfly/onfly" + string(getenv("analyze_begin_case")) + "-" + 
                        string(getenv("analyze_end_case")) + ".dat";
    
    std::cout << "Loading data..." << endl;
    
    LoadDataResult data = loadOnflyData3D(filename);
    
    //添加对数组降维的支持
    if (data.ret.empty() || data.totFrames == 0) {
        cerr << "Error: No data loaded or unexpected format!" << endl;
        return -1;
    }
    
    // 使用ret (多帧4D数组)
    auto& retData = data.ret;
    
    int num_frames = data.totFrames;
    int nx = retData[0].size();
    int ny = retData[0][0].size();
    int nz = retData[0][0][0].size();
    int total_cols = retData[0][0][0].size();  // col维度大小
    int groups = total_cols / 4;  // 假设12 cols -> 3 groups
    
    cout << "Frames: " << num_frames << ", Groups: " << groups << endl;
    cout << "Dimensions: " << nx << " x " << ny << " x " << nz << " x " << total_cols << endl;
    cout << "Total spatial points: " << (nx * ny * nz) << endl;
    
    int total_spatial_points = nx * ny * nz;
    
    // charge_d 和 density_d: vector< vector< vector<double> > > (groups x (spatial x frames))
    // 但为节省内存，用 vector< vector<double> > (spatial x frames) per group
    vector< vector< vector<double> > > charge_d(groups);
    vector< vector< vector<double> > > density_d(groups);
    
    // 初始化总charge/density
    vector< vector<double> > charge(total_spatial_points, vector<double>(num_frames, 0.0));
    vector< vector<double> > density(total_spatial_points, vector<double>(num_frames, 0.0));
    
    // 主循环: for n=1 to groups (0-based n=0 to groups-1)
    for (int n = 0; n < groups; ++n) {
        // 初始化当前group
        charge_d[n] = vector< vector<double> >(total_spatial_points, vector<double>(num_frames, 0.0));
        density_d[n] = vector< vector<double> >(total_spatial_points, vector<double>(num_frames, 0.0));
        
        // for i=1 to num_frames (0-based i=0 to num_frames-1)
        for (int i = 0; i < num_frames; ++i) {
            int spatial_idx = 0;
            
            // 按column-major顺序遍历spatial点: x-y-z
            for (int x = 0; x < nx; ++x) {
                for (int y = 0; y < ny; ++y) {
                    for (int z = 0; z < nz; ++z) {
                        // MATLAB col: (n-1)*4 + 3 for charge -> 0-based: n*4 + 2
                        // (n-1)*4 + 2 for density -> n*4 + 1
                        int charge_col = n * 4 + 2;
                        int density_col = n * 4 + 1;
                        
                        if (charge_col < total_cols) {
                            charge_d[n][spatial_idx][i] = retData[i][x][y][z][charge_col];
                        }
                        if (density_col < total_cols) {
                            density_d[n][spatial_idx][i] = retData[i][x][y][z][density_col];
                        }
                        
                        ++spatial_idx;
                    }
                }
            }
        }
        
        // 累加到总charge/density (MATLAB: if n==1 then = else += )
        for (int sp = 0; sp < total_spatial_points; ++sp) {
            for (int f = 0; f < num_frames; ++f) {
                charge[sp][f] += charge_d[n][sp][f];
                density[sp][f] += density_d[n][sp][f];
            }
        }
    }
    
    // 对应MATLAB: plot(charge(:,1)) - 打印第一帧charge的前20个spatial点值
    cout << "\nCharge data (first frame, first 20 spatial points):" << endl;
    for (int i = 0; i < min(20, total_spatial_points); ++i) {
        cout << fixed << setprecision(8) << charge[i][0] << endl;
    }
    
    // 保存数据到.txt (模拟.mat: 保存所有变量，space-separated)
    // 为匹配MATLAB，保存charge, charge_d[0..2], density, density_d[0..2]
    // 每个变量: 先header行 (dims), 然后数据行 (row-major: spatial x frames)
    ostringstream oss;
    oss << "./meandata/ACNcharge298k" << V << "V" << scanrate << "ps_1_54.txt";
    string savedir = oss.str();
    cout << "\nSaving data to: " << savedir << endl;
    
    ofstream outfile(savedir);
    if (outfile.is_open()) {
        outfile << scientific << setprecision(10);
        
        // 保存charge
        outfile << "# charge: " << charge.size() << " x " << charge[0].size() << "\n";
        for (const auto& row : charge) {
            for (const auto& val : row) {
                outfile << val << " ";
            }
            outfile << "\n";
        }
        outfile << "# --- END charge ---\n\n";
        
        // 保存charge_d (3 groups)
        for (int g = 0; g < groups; ++g) {
            outfile << "# charge_d[" << g << "]: " << charge_d[g].size() << " x " << charge_d[g][0].size() << "\n";
            for (const auto& row : charge_d[g]) {
                for (const auto& val : row) {
                    outfile << val << " ";
                }
                outfile << "\n";
            }
            outfile << "# --- END charge_d[" << g << "] ---\n";
        }
        outfile << "# --- END charge_d ---\n\n";
        
        // 保存density (类似)
        outfile << "# density: " << density.size() << " x " << density[0].size() << "\n";
        for (const auto& row : density) {
            for (const auto& val : row) {
                outfile << val << " ";
            }
            outfile << "\n";
        }
        outfile << "# --- END density ---\n\n";
        
        // 保存density_d
        for (int g = 0; g < groups; ++g) {
            outfile << "# density_d[" << g << "]: " << density_d[g].size() << " x " << density_d[g][0].size() << "\n";
            for (const auto& row : density_d[g]) {
                for (const auto& val : row) {
                    outfile << val << " ";
                }
                outfile << "\n";
            }
            outfile << "# --- END density_d[" << g << "] ---\n";
        }
        outfile << "# --- END density_d ---\n\n";
        
        outfile.close();
        cout << "Data saved successfully." << endl;
    } else {
        cerr << "Error: Cannot save to " << savedir << endl;
    }
    
    cout << "\nProcessing completed!" << endl;
    
    return 0;
}